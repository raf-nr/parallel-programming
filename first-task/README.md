# Стек Трайбера.

## Реализация
Реализованы 3 вида стека - последовательный, стек Трайбера (потокобезопасный стек) и стек Трайбера с оптимизацией с элиминацией (далее называем его просто стек с оптимизацией).
Каждый поддерживает 4 основные операции:

- `Push` - добавления элемента на вершину стека.
- `Pop` - удаление элемента с вершины стека.
- `Peek` - получение верхнего элемента стека.
- `Len` - размер стека / количество элементов в стеке.

## Тестирование
Для запуска тестов:
```bash
❯ go test ./tests/ -v
```

Для запуска `benchmarks`:
```bash
❯ go test ./tests/benchmarks/ -v -bench=.
```
Для провер на  `race-conditions` достаточно добавить к командам флаг `race`.

## Эксперимент

### Условия проведения эксперимента
- Процессор — **Apple M1 Pro (8 ядер).**
- Оперативная память — **16 GB.**
- Операционная система — **macOS Sonoma 14.0.**
- L1-кэш — **256 KB.**

### Количество измерений
Все замеры проводились 10 раз, а затем в качестве результата бралось среднее арифметическое, если не указано иное.

### Последовательные сценарии
На данных сценариях запускались все реализованные виды стека.
- Последовательно `Push` - `1000000` раз.
- Последовательно `Pop` - `1000000` раз.
- Пары `Push` и `Pop` - `1000000` раз.
- `Push` - `1000000` раз, а затем `Pop` - `1000000` раз.
- `Push` и `Pop` в рандомном порядке - суммарно `1000000` раз.

### Параллельные сценарии
На данных сценариях запускались стек Трайбера и стек с оптимизацией (Размер массива "обменников" - `10`, количество попыток на проведение обмена - `500`).
- Параллельно `Push` - `1000000` раз, используя `1000000` горутин (1 горутина - 1 операция).
- Параллельно `Pop` - аналогично предыдущему сценарию.
- Пары `Push` и `Pop` - `1000000` раз, используя `8` горутин.
- Пары `Push` и `Pop` - `1000000` раз, используя `100` горутин.
- Пары `Push` и `Pop` - `1000000` раз, используя `1000000` горутин.
- Сначало параллельно `Push` - `1000000` раз, затем параллельно `Pop` - `1000000` раз, используя `2000000` горутин.
- `Push` и `Pop` параллельно в рандомном порядке - суммарно `1000000` раз, используя `8` горутин.
- `Push` и `Pop` параллельно в рандомном порядке - суммарно `1000000` раз, используя `100` горутин.
- `Push` и `Pop` параллельно в рандомном порядке - суммарно `1000000` раз, используя `1000000` горутин.

### Результаты
С результатами можно ознакомиться в [./results.txt](файле), либо в [таблице](https://docs.google.com/spreadsheets/d/1KOKXEaoHJ18Cn4LVSi3V27JuhZZlCVTMsGhuEVMlYzg/edit?usp=sharing). В качестве метрики использовалось среднее время, затраченное на выполнение каждого сценария (в наносекундах).

По этим результатам можно сделать следующие заключения:

- На любых последовательных сценариях обычный стек будет работать быстрее стека Трайбера с/без оптимизации с элиминацией.
- Когда у нас количество одной операции (например, `Push`) значительно перевешивает количество колиментарной операции (`Pop`) стек Трайбера работает быстрее стека с оптимизацией.
- (Следствие из 2): на сценариях, где у нас только `Push` или только `Pop` обычный стек Трайбера работает немного быстрее.
- В случае, кода мы сначала делаем все `Push`, а затем все `Pop` стек Трайбера работает быстрее стека с оптимизацией.
- Стек с оптимизацией работает значительно быстрее стека Трайбера на сценариях, где у нас `Push` и `Pop` следуют почти друг за другом.
- Стек с оптимизацией работает значительно быстрее стека Трайбера на сценариях, где у нас `Push` и `Pop` выполняются в случайно порядке (50/50) (хотя опять же, это следствие из предыдущего пункта и справедливо только тогда, когда нам повезло с порядком выполеения операций).
- Количество горутин сильно влияет на скорость работы стека Трайбера и стека с оптимизацией. В частности, когда мы использовали `8` и `100` горутин для работы с `1000000` элементами - это было намного эффективнее (для стека с оптимизацией получили большое ускорение), чем когда мы использовали `1000000` горутин для работы с `1000000` элементами (для стека с оптимизацией получили небольшое замедление), что достаточно логично.